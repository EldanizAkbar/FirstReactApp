{"ast":null,"code":"// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i; // node names which could be successful controls\n\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i; // Matches bracket notation.\n\nvar brackets = /(\\[[^\\[\\]]*\\])/g; // serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\n\nfunction serialize(form, options) {\n  if (typeof options != 'object') {\n    options = {\n      hash: !!options\n    };\n  } else if (options.hash === undefined) {\n    options.hash = true;\n  }\n\n  var result = options.hash ? {} : '';\n  var serializer = options.serializer || (options.hash ? hash_serializer : str_serialize);\n  var elements = form && form.elements ? form.elements : []; //Object store each radio and set if it's empty or not\n\n  var radio_store = Object.create(null);\n\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i]; // ingore disabled fields\n\n    if (!options.disabled && element.disabled || !element.name) {\n      continue;\n    } // ignore anyhting that is not considered a success field\n\n\n    if (!k_r_success_contrls.test(element.nodeName) || k_r_submitter.test(element.type)) {\n      continue;\n    }\n\n    var key = element.name;\n    var val = element.value; // we can't just use element.value for checkboxes cause some browsers lie to us\n    // they say \"on\" for value when the box isn't checked\n\n    if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n      val = undefined;\n    } // If we want empty elements\n\n\n    if (options.empty) {\n      // for checkbox\n      if (element.type === 'checkbox' && !element.checked) {\n        val = '';\n      } // for radio\n\n\n      if (element.type === 'radio') {\n        if (!radio_store[element.name] && !element.checked) {\n          radio_store[element.name] = false;\n        } else if (element.checked) {\n          radio_store[element.name] = true;\n        }\n      } // if options empty is true, continue only if its radio\n\n\n      if (val == undefined && element.type == 'radio') {\n        continue;\n      }\n    } else {\n      // value-less fields are ignored unless options.empty is true\n      if (!val) {\n        continue;\n      }\n    } // multi select boxes\n\n\n    if (element.type === 'select-multiple') {\n      val = [];\n      var selectOptions = element.options;\n      var isSelectedOptions = false;\n\n      for (var j = 0; j < selectOptions.length; ++j) {\n        var option = selectOptions[j];\n        var allowedEmpty = options.empty && !option.value;\n        var hasValue = option.value || allowedEmpty;\n\n        if (option.selected && hasValue) {\n          isSelectedOptions = true; // If using a hash serializer be sure to add the\n          // correct notation for an array in the multi-select\n          // context. Here the name attribute on the select element\n          // might be missing the trailing bracket pair. Both names\n          // \"foo\" and \"foo[]\" should be arrays.\n\n          if (options.hash && key.slice(key.length - 2) !== '[]') {\n            result = serializer(result, key + '[]', option.value);\n          } else {\n            result = serializer(result, key, option.value);\n          }\n        }\n      } // Serialize if no selected options and options.empty is true\n\n\n      if (!isSelectedOptions && options.empty) {\n        result = serializer(result, key, '');\n      }\n\n      continue;\n    }\n\n    result = serializer(result, key, val);\n  } // Check for all empty radio buttons and serialize them with key=\"\"\n\n\n  if (options.empty) {\n    for (var key in radio_store) {\n      if (!radio_store[key]) {\n        result = serializer(result, key, '');\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction parse_keys(string) {\n  var keys = [];\n  var prefix = /^([^\\[\\]]*)/;\n  var children = new RegExp(brackets);\n  var match = prefix.exec(string);\n\n  if (match[1]) {\n    keys.push(match[1]);\n  }\n\n  while ((match = children.exec(string)) !== null) {\n    keys.push(match[1]);\n  }\n\n  return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n  if (keys.length === 0) {\n    result = value;\n    return result;\n  }\n\n  var key = keys.shift();\n  var between = key.match(/^\\[(.+?)\\]$/);\n\n  if (key === '[]') {\n    result = result || [];\n\n    if (Array.isArray(result)) {\n      result.push(hash_assign(null, keys, value));\n    } else {\n      // This might be the result of bad name attributes like \"[][foo]\",\n      // in this case the original `result` object will already be\n      // assigned to an object literal. Rather than coerce the object to\n      // an array, or cause an exception the attribute \"_values\" is\n      // assigned as an array.\n      result._values = result._values || [];\n\n      result._values.push(hash_assign(null, keys, value));\n    }\n\n    return result;\n  } // Key is an attribute name and can be assigned directly.\n\n\n  if (!between) {\n    result[key] = hash_assign(result[key], keys, value);\n  } else {\n    var string = between[1]; // +var converts the variable into a number\n    // better than parseInt because it doesn't truncate away trailing\n    // letters and actually fails if whole thing is not a number\n\n    var index = +string; // If the characters between the brackets is not a number it is an\n    // attribute name and can be assigned directly.\n\n    if (isNaN(index)) {\n      result = result || {};\n      result[string] = hash_assign(result[string], keys, value);\n    } else {\n      result = result || [];\n      result[index] = hash_assign(result[index], keys, value);\n    }\n  }\n\n  return result;\n} // Object/hash encoding serializer.\n\n\nfunction hash_serializer(result, key, value) {\n  var matches = key.match(brackets); // Has brackets? Use the recursive assignment function to walk the keys,\n  // construct any missing objects in the result tree and make the assignment\n  // at the end of the chain.\n\n  if (matches) {\n    var keys = parse_keys(key);\n    hash_assign(result, keys, value);\n  } else {\n    // Non bracket notation can make assignments directly.\n    var existing = result[key]; // If the value has been assigned already (for instance when a radio and\n    // a checkbox have the same name attribute) convert the previous value\n    // into an array before pushing into it.\n    //\n    // NOTE: If this requirement were removed all hash creation and\n    // assignment could go through `hash_assign`.\n\n    if (existing) {\n      if (!Array.isArray(existing)) {\n        result[key] = [existing];\n      }\n\n      result[key].push(value);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result;\n} // urlform encoding serializer\n\n\nfunction str_serialize(result, key, value) {\n  // encode newlines as \\r\\n cause the html spec says so\n  value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n  value = encodeURIComponent(value); // spaces should be '+' rather than '%20'.\n\n  value = value.replace(/%20/g, '+');\n  return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;","map":{"version":3,"sources":["C:/Users/elden/Desktop/React projects/New project/my-app/node_modules/form-serialize/index.js"],"names":["k_r_submitter","k_r_success_contrls","brackets","serialize","form","options","hash","undefined","result","serializer","hash_serializer","str_serialize","elements","radio_store","Object","create","i","length","element","disabled","name","test","nodeName","type","key","val","value","checked","empty","selectOptions","isSelectedOptions","j","option","allowedEmpty","hasValue","selected","slice","parse_keys","string","keys","prefix","children","RegExp","match","exec","push","hash_assign","shift","between","Array","isArray","_values","index","isNaN","matches","existing","replace","encodeURIComponent","module","exports"],"mappings":"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","sourcesContent":["// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n    if (typeof options != 'object') {\n        options = { hash: !!options };\n    }\n    else if (options.hash === undefined) {\n        options.hash = true;\n    }\n\n    var result = (options.hash) ? {} : '';\n    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);\n\n    var elements = form && form.elements ? form.elements : [];\n\n    //Object store each radio and set if it's empty or not\n    var radio_store = Object.create(null);\n\n    for (var i=0 ; i<elements.length ; ++i) {\n        var element = elements[i];\n\n        // ingore disabled fields\n        if ((!options.disabled && element.disabled) || !element.name) {\n            continue;\n        }\n        // ignore anyhting that is not considered a success field\n        if (!k_r_success_contrls.test(element.nodeName) ||\n            k_r_submitter.test(element.type)) {\n            continue;\n        }\n\n        var key = element.name;\n        var val = element.value;\n\n        // we can't just use element.value for checkboxes cause some browsers lie to us\n        // they say \"on\" for value when the box isn't checked\n        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n            val = undefined;\n        }\n\n        // If we want empty elements\n        if (options.empty) {\n            // for checkbox\n            if (element.type === 'checkbox' && !element.checked) {\n                val = '';\n            }\n\n            // for radio\n            if (element.type === 'radio') {\n                if (!radio_store[element.name] && !element.checked) {\n                    radio_store[element.name] = false;\n                }\n                else if (element.checked) {\n                    radio_store[element.name] = true;\n                }\n            }\n\n            // if options empty is true, continue only if its radio\n            if (val == undefined && element.type == 'radio') {\n                continue;\n            }\n        }\n        else {\n            // value-less fields are ignored unless options.empty is true\n            if (!val) {\n                continue;\n            }\n        }\n\n        // multi select boxes\n        if (element.type === 'select-multiple') {\n            val = [];\n\n            var selectOptions = element.options;\n            var isSelectedOptions = false;\n            for (var j=0 ; j<selectOptions.length ; ++j) {\n                var option = selectOptions[j];\n                var allowedEmpty = options.empty && !option.value;\n                var hasValue = (option.value || allowedEmpty);\n                if (option.selected && hasValue) {\n                    isSelectedOptions = true;\n\n                    // If using a hash serializer be sure to add the\n                    // correct notation for an array in the multi-select\n                    // context. Here the name attribute on the select element\n                    // might be missing the trailing bracket pair. Both names\n                    // \"foo\" and \"foo[]\" should be arrays.\n                    if (options.hash && key.slice(key.length - 2) !== '[]') {\n                        result = serializer(result, key + '[]', option.value);\n                    }\n                    else {\n                        result = serializer(result, key, option.value);\n                    }\n                }\n            }\n\n            // Serialize if no selected options and options.empty is true\n            if (!isSelectedOptions && options.empty) {\n                result = serializer(result, key, '');\n            }\n\n            continue;\n        }\n\n        result = serializer(result, key, val);\n    }\n\n    // Check for all empty radio buttons and serialize them with key=\"\"\n    if (options.empty) {\n        for (var key in radio_store) {\n            if (!radio_store[key]) {\n                result = serializer(result, key, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction parse_keys(string) {\n    var keys = [];\n    var prefix = /^([^\\[\\]]*)/;\n    var children = new RegExp(brackets);\n    var match = prefix.exec(string);\n\n    if (match[1]) {\n        keys.push(match[1]);\n    }\n\n    while ((match = children.exec(string)) !== null) {\n        keys.push(match[1]);\n    }\n\n    return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n    if (keys.length === 0) {\n        result = value;\n        return result;\n    }\n\n    var key = keys.shift();\n    var between = key.match(/^\\[(.+?)\\]$/);\n\n    if (key === '[]') {\n        result = result || [];\n\n        if (Array.isArray(result)) {\n            result.push(hash_assign(null, keys, value));\n        }\n        else {\n            // This might be the result of bad name attributes like \"[][foo]\",\n            // in this case the original `result` object will already be\n            // assigned to an object literal. Rather than coerce the object to\n            // an array, or cause an exception the attribute \"_values\" is\n            // assigned as an array.\n            result._values = result._values || [];\n            result._values.push(hash_assign(null, keys, value));\n        }\n\n        return result;\n    }\n\n    // Key is an attribute name and can be assigned directly.\n    if (!between) {\n        result[key] = hash_assign(result[key], keys, value);\n    }\n    else {\n        var string = between[1];\n        // +var converts the variable into a number\n        // better than parseInt because it doesn't truncate away trailing\n        // letters and actually fails if whole thing is not a number\n        var index = +string;\n\n        // If the characters between the brackets is not a number it is an\n        // attribute name and can be assigned directly.\n        if (isNaN(index)) {\n            result = result || {};\n            result[string] = hash_assign(result[string], keys, value);\n        }\n        else {\n            result = result || [];\n            result[index] = hash_assign(result[index], keys, value);\n        }\n    }\n\n    return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n    var matches = key.match(brackets);\n\n    // Has brackets? Use the recursive assignment function to walk the keys,\n    // construct any missing objects in the result tree and make the assignment\n    // at the end of the chain.\n    if (matches) {\n        var keys = parse_keys(key);\n        hash_assign(result, keys, value);\n    }\n    else {\n        // Non bracket notation can make assignments directly.\n        var existing = result[key];\n\n        // If the value has been assigned already (for instance when a radio and\n        // a checkbox have the same name attribute) convert the previous value\n        // into an array before pushing into it.\n        //\n        // NOTE: If this requirement were removed all hash creation and\n        // assignment could go through `hash_assign`.\n        if (existing) {\n            if (!Array.isArray(existing)) {\n                result[key] = [ existing ];\n            }\n\n            result[key].push(value);\n        }\n        else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n    // encode newlines as \\r\\n cause the html spec says so\n    value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n    value = encodeURIComponent(value);\n\n    // spaces should be '+' rather than '%20'.\n    value = value.replace(/%20/g, '+');\n    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;\n"]},"metadata":{},"sourceType":"script"}